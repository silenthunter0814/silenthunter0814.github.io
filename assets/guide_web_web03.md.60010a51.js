import{_ as s,o as a,c as l,Q as n}from"./chunks/framework.8f76c11e.js";const h=JSON.parse('{"title":"Javascript 忍者秘籍","description":"ninja 忍者。javascript 课程课件，学习笔记。","frontmatter":{"description":"ninja 忍者。javascript 课程课件，学习笔记。","author":"silenthunter0814, Silent Hunter"},"headers":[],"relativePath":"guide/web/web03.md","filePath":"guide/web/web03.md","lastUpdated":1693533591000}'),o={name:"guide/web/web03.md"},p=n(`<h1 id="javascript-忍者秘籍" tabindex="-1">Javascript 忍者秘籍 <a class="header-anchor" href="#javascript-忍者秘籍" aria-label="Permalink to &quot;Javascript 忍者秘籍&quot;">​</a></h1><p>book: Secrets of the JavaScript Ninja, Second Edition<br> authors: John Resig, Bear Bibeault, Josip Maras</p><p>课程视频：</p><ul><li>油管: <a href="https://youtube.com/@silenthunter0814" target="_blank" rel="noreferrer">https://youtube.com/@silenthunter0814</a></li><li>B 站：<a href="https://space.bilibili.com/1551957972" target="_blank" rel="noreferrer">https://space.bilibili.com/1551957972</a></li></ul><hr><details><summary>章节目录</summary><nav class="table-of-contents"><ul><li><a href="#_0-es6-速查表">0 ES6 速查表</a></li><li><a href="#_1-javascript-无处不在">1 JavaScript 无处不在</a><ul><li><a href="#_1-1-理解javascript语言">1.1 理解JavaScript语言</a></li><li><a href="#_1-2-了解浏览器">1.2 了解浏览器</a></li><li><a href="#_1-3-使用当前最佳实践">1.3 使用当前最佳实践</a></li></ul></li></ul></nav></details><h2 id="_0-es6-速查表" tabindex="-1">0 ES6 速查表 <a class="header-anchor" href="#_0-es6-速查表" aria-label="Permalink to &quot;0 ES6 速查表&quot;">​</a></h2><ol><li>模板文字将表达式嵌入到字符串中</li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#9ECBFF;">\`\${</span><span style="color:#E1E4E8;">ninja</span><span style="color:#9ECBFF;">}\`</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">\`\${</span><span style="color:#24292E;">ninja</span><span style="color:#032F62;">}\`</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="2"><li>块作用域变量</li></ol><ul><li>使用新的 <code>let</code> 关键字创建块级变量：<br><code>let ninja = “Yoshi”</code></li><li>使用 <code>const</code> 关键字创建块级常量变量，其值不能重新分配为全新值：<br><code>const ninja = &quot;Yoshi&quot;</code></li></ul><ol start="3"><li>函数参数</li></ol><ul><li>剩余参数根据与参数不匹配的参数创建一个数组：</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">multiMax</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">first</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">remaining</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/* ... */</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#B392F0;">multiMax</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// first: 2; remaining: [3, 4, 5]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">multiMax</span><span style="color:#24292E;">(</span><span style="color:#E36209;">first</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">...</span><span style="color:#E36209;">remaining</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/* ... */</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6F42C1;">multiMax</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// first: 2; remaining: [3, 4, 5]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>默认参数指定在调用期间未提供值时使用的默认参数值：</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">ninja</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">action</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;skulk&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ninja </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot; &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> action;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Fuma&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// &quot;Fuma skulk&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">(</span><span style="color:#E36209;">ninja</span><span style="color:#24292E;">, </span><span style="color:#E36209;">action</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;skulk&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ninja </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot; &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> action;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Fuma&quot;</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// &quot;Fuma skulk&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="4"><li><p>扩展运算符扩展需要多个项目的表达式：<br><code>[...items, 3, 4, 5]</code></p></li><li><p>箭头函数没有自己的 <code>this</code> 参数。 相反，它们从创建它们的上下文中继承它</p></li></ol><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">values</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">7</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">values.</span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">v1</span><span style="color:#E1E4E8;">,</span><span style="color:#FFAB70;">v2</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> v1 </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> v2);</span></span>
<span class="line"><span style="color:#E1E4E8;">values.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(value));</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">values</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">7</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">8</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">values.</span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">((</span><span style="color:#E36209;">v1</span><span style="color:#24292E;">,</span><span style="color:#E36209;">v2</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> v1 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> v2);</span></span>
<span class="line"><span style="color:#24292E;">values.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(value));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="6"><li>Promise 是计算结果的占位符</li></ol><ul><li>Promise 是我们最终会知道某些计算结果的保证。</li><li>Promise 要么成功，要么失败，一旦成功，就不会再有任何变化。</li><li>创建一个新的承诺:<br><code>new Promise((resolve, reject) =&gt; {});</code></li><li>调用 <code>resolve</code> 函数来显式解析 Promise。</li><li>调用 <code>reject</code> 函数来显式拒绝承诺。 如果发生错误，承诺将被隐式拒绝。</li><li>Promise 对象有一个 <code>then</code> 方法，它返回一个 Promise 并接受两个回调，一个成功回调和一个失败回调：<br><code>myPromise.then(val =&gt; console.log(&quot;Success&quot;), err =&gt; console.log(&quot;Error&quot;));</code></li><li>链入 <code>catch</code> 方法以捕获承诺失败：<br><code>myPromise.catch(e =&gt; alert(e));</code></li></ul><h2 id="_1-javascript-无处不在" tabindex="-1">1 JavaScript 无处不在 <a class="header-anchor" href="#_1-javascript-无处不在" aria-label="Permalink to &quot;1 JavaScript 无处不在&quot;">​</a></h2><p>本章涵盖</p><ul><li>JavaScript 的核心语言特性</li><li>JavaScript 引擎的核心项目</li><li>JavaScript 开发的三个最佳实践</li></ul><h3 id="_1-1-理解javascript语言" tabindex="-1">1.1 理解JavaScript语言 <a class="header-anchor" href="#_1-1-理解javascript语言" aria-label="Permalink to &quot;1.1 理解JavaScript语言&quot;">​</a></h3><p>与其他主流语言相比，JavaScript 更加注重功能。 一些 JavaScript 概念与大多数其他语言的概念有着根本的不同。</p><p>这些差异包括以下内容：</p><ol><li>函数是一等对象——在 JavaScript 中，函数与任何其他 JavaScript 对象共存，并且可以像对待任何其他 JavaScript 对象一样对待。 它们可以通过文字创建、由变量引用、作为函数参数传递，甚至作为函数返回值返回。</li><li>函数闭包——函数闭包的概念通常不太被理解，现在，只要知道一个函数在主动维护（“关闭”）其主体中使用的外部变量时就是一个闭包就足够了。</li><li>基于原型的面向对象——与使用基于类的面向对象的其他主流编程语言（例如 C#、Java 和 Ruby）不同，JavaScript 使用原型。</li></ol><p>JavaScript 由对象和原型、函数和闭包之间的密切关系组成。其他 JavaScript 功能可以帮助您编写更优雅、更高效的代码：</p><ul><li>生成器，这些函数可以根据每个请求生成多个值，并且可以在请求之间暂停其执行</li><li>Promise，让我们更好地控制异步代码</li><li>代理，允许我们控制对某些对象的访问</li><li>高级数组方法，使数组处理代码更加优雅</li><li><code>map</code>，我们可以用它来创建字典集合； 和 <code>set</code>，这使我们能够处理独特项目的集合</li><li>正则表达式，它让我们简化原本复杂的代码片段</li><li>模块，我们可以用它来将代码分解成更小的、相对独立的部分，使项目更易于管理</li></ul><h3 id="_1-2-了解浏览器" tabindex="-1">1.2 了解浏览器 <a class="header-anchor" href="#_1-2-了解浏览器" aria-label="Permalink to &quot;1.2 了解浏览器&quot;">​</a></h3><p>浏览器提供各种概念和API供深入探索； 见图1.1：</p><p><img src="https://silenthunter0814.github.io/pub/web03/1.1.png" alt=""></p><p>我们将重点关注以下内容：</p><ul><li>文档对象模型 (DOM) — DOM 是客户端 Web 应用程序 UI 的结构化表示。 要开发出色的应用程序，您不仅需要深入了解 JavaScript 的核心机制，还需要研究 DOM 的构造方式（第 2 章）以及如何编写有效的代码来操作 DOM（第 12 章）。 这将使高级、高度动态的 UI 的创建触手可及。</li><li>事件——绝大多数 JavaScript 应用程序都是事件驱动的应用程序，这意味着大多数代码是在响应特定事件的上下文中执行的。 事件的示例包括网络事件、计时器和用户生成的事件（例如单击、鼠标移动、按下键盘等）。 因此，我们将在第 13 章中彻底探索事件背后的机制。我们将特别关注计时器，它通常是一个谜，但让我们能够处理复杂的编码任务，例如长时间运行的计算和平滑的动画。</li><li>浏览器 API——为了帮助我们与世界互动，浏览器提供了一个 API，允许我们访问有关设备的信息、在本地存储数据或与远程服务器通信。 我们将在整本书中探讨其中一些 API。</li></ul><h3 id="_1-3-使用当前最佳实践" tabindex="-1">1.3 使用当前最佳实践 <a class="header-anchor" href="#_1-3-使用当前最佳实践" aria-label="Permalink to &quot;1.3 使用当前最佳实践&quot;">​</a></h3><p>最佳实践除了对语言的掌握之外，包括以下要素：</p><ul><li>调试技巧</li><li>测试</li><li>性能分析</li></ul>`,37),e=[p];function t(r,c,i,E,y,u){return a(),l("div",null,e)}const v=s(o,[["render",t]]);export{h as __pageData,v as default};
